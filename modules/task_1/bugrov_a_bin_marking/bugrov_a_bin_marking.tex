\documentclass[14pt]{extarticle}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[a4paper, left=2cm, right=2cm, top=2cm, bottom=2cm]{geometry}
\usepackage[english, russian]{babel} % русский и переносы
\usepackage{color,colortbl}

\usepackage{graphicx} % Фотографии
\usepackage{hyperref} % Кликабельное оглавление
\usepackage{multirow} % Объединение строк и столбцов таблицы

\setlength{\parindent}{0.8cm} % Красная строка
\setlength{\parskip}{0.4cm} % Отступ между абзацами
\renewcommand{\contentsname}{}

\hypersetup{
colorlinks,
citecolor=black,
filecolor=black,
linkcolor=black,
urlcolor=black,
}
\graphicspath{ {./img} } % Папка с фото
\newcounter{PicID}
\setcounter{PicID}{1}
\newcommand{\MyPic}[3]{
    \stepcounter{PicID}
    \hfill \includegraphics[scale=#3]{#1} \hfill\break
    {\centering Рис.\thePicID \hspace{1mm} #2 \par}
}

\title{}
\author{}
\date{}

\begin{document}
	% Титульный лист
	\begin{titlepage}
		\begin{center}
			{\bfseries МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ \\
				РОССИЙСКОЙ ФЕДЕРАЦИИ}
			\\
			Федеральное государственное автономное образовательное учреждение высшего образования
			\\
			{\bfseries «Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского»\\(ННГУ)
				\\Институт информационных технологий, математики и механики} \\
		\end{center}

		\vspace{8em}

		\begin{center}
			ОТЧЁТ \\ по лабораторной работе \\
			«Маркировка компонент на бинарном изображении (черные области соответствуют объектам, белые – фону)»
		\end{center}

		\vspace{5em}


		\begin{flushright}
			{\bfseries Выполнил:} студент группы\\382006-2\\Бугров А.В. \underline{\hspace{3cm}} \linebreak\linebreak\linebreak
			{\bfseries Проверил:} младший научный\\ сотрудник\\Нестеров А.Ю. \underline{\hspace{3cm}}
		\end{flushright}


		\vspace{\fill}

		\begin{center}
			Нижний Новгород\\2023
		\end{center}

	\end{titlepage}
 \newpage
\tableofcontents
\newpage
\section{Введение}
\paragraph{} Бинарные изображения, иначе говоря, чёрно-белые, несмотря на наличие современных технологий, широко распространены. Одна из наиболее важных задач, связанных с ними, - это маркировка подключённых компонент. В литературе также можно встретить другие названия - маркировка связанных компонент (CCL) и анализ связанных компонент (CCA).
\par Маркировка связанных компонент в бинарных изображениях - алгоритмическое приложение теории графов, где подмножества связанных компонентов однозначно помечаются на основе заданной эвристики . Это один из базовых алгоритмов анализа и обработки изображений. В частности, он может быть использован в компьютерном зрении для поиска и подсчета единых структур в изображении с последующих их анализом.
\par Связанные компоненты - это, говоря простым языком, такие области бинарного изображения, в которых любой нефоновый пиксель помечен ровно так же, как и его сосед, тоже не являющийся фоновым пикселем. Здесь и далее под связностью подразумевается 4-связность, то есть соседями пикселя, имеющими с ним одну метку, могут быть только те пиксели, которые расположены сверху, снизу или сбоку от данного.
\newpage
\section{Постановка задачи}
\paragraph{} Разработать на языке C++ программный продукт, способный корректно выполнить маркировку связанных компонент в бинарном изображении. Данная задача подразумевает под собой выполнение следующих этапов:
\begin{enumerate}
    \item Поиск и анализ теоретического материала;
    \item Последовательная реализация поставленной задачи;
    \item Написание тестов, проверяющих корректность алгоритма;
    \item Параллельная реализация поставленной задачи при помощи OpenMP;
    \item Параллельная реализация поставленной задачи при помощи TBB;
    \item Параллельная реализация поставленной задачи при помощи std::thread;
    \item Оформление отчёта по проделанной работе.
\end{enumerate}
\newpage
\section{Описание последовательного алгоритма}
\paragraph{}В качестве последовательного алгоритма был выбран однопроходной.
\par \textbf{Описание шагов алгоритма:}
\begin{enumerate}
    \item Начать с первого пикселя изображения. Установите текущую метку на 1. Перейдите к шагу 2.
    \item Если этот пиксель является пикселем переднего плана и он еще не помечен, присвойте ему текущую метку и добавьте его как первый элемент в очередь, затем перейдите к шагу 3. Если это фоновый пиксель или он уже был помечен, повторите шаг 2 для следующего пикселя изображения.
    \item Вытащите элемент из очереди и посмотрите на его соседей (на основе любого типа возможность подключения). Если сосед является пикселем переднего плана и еще не помечен, присвойте ему текущую метку и добавьте его в очередь. Повторяйте шаг 3, пока в очереди не останется больше элементов.
    \item Перейдите к шагу 2 для следующего пикселя в изображении и увеличьте текущую метку на 1.
\end{enumerate}
\par Согласно названию лабораторной работы, чёрные пиксели (нули) соответствуют объектам, а белые (единицы) - фону. Поэтому можно привести следующий пример работы алгоритма:
\par
\hfill
\begin{tabular}{ |c c c c c| }
\hline
 1 & 1 & 1 & 0 & 0\\
 1 & 0 & 1 & 0 & 0\\
 0 & 0 & 1 & 1 & 0\\
 1 & 1 & 0 & 1 & 0\\
 0 & 0 & 1 & 1 & 0\\
 \hline
 \multicolumn{5}{c}{Изображение}
\end{tabular}
\qquad
\begin{tabular}{ |c c c c c| }
\hline
 0 & 0 & 0 & 1 & 1\\
 0 & 2 & 0 & 1 & 1\\
 2 & 2 & 0 & 0 & 1\\
 0 & 0 & 3 & 0 & 1\\
 4 & 4 & 0 & 0 & 1\\
 \hline
 \multicolumn{5}{c}{Маркировка}
\end{tabular}
\hfill \break
\newpage
\section{Описание схемы распараллеливания}
Основная проблема распараллеливания алгоритма маркировки компонент - это слияние результатов работы параллельных потоков в один конечный результат. Причины этому следующие:
\begin{enumerate}
    \item Существует большое количество сложных примеров, которые порождают ошибки, если выполнять слияние очевидными методами;
    \item Необходимо реализовать также алгоритм перенумеровки, так как у каждого потока своя нумерация.
\end{enumerate}
\par В связи с этим был выбран совершенно иной алгоритм, а именно: алгоритм эквивалентных отрезков. Основную часть работы алгоритм имеет дело не с изображением, и даже не с матрицей меток, а с картой отрезков.
\par Карта отрезков - структура данных в виде массива размером \(n\cdot(m/2+1)\), где \(n\) - количество строк пикселей изображения, \(m\) - количество столбцов пикселей в изображении.
\par \textbf{Каждый отрезок хранит в себе следующую информацию:}
\begin{enumerate}
    \item Метка
    \item Левая граница;
    \item Правая граница;
    \item Самый левый соседний отрезок на предыдущей строке;
    \item Самый правый соседний отрезок на предыдущей строке;
    \item Самый левый соседний отрезок на следующей строке;
    \item  Самый правый соседний отрезок на следующей строке;
\end{enumerate}
\par Если из вышеперечисленных значений каких-либо нет, ставится 0 (важно, что метки нумерутся от единицы).
\par \textbf{Алгоритм использует 5 шагов:}
\begin{enumerate}
    \item Инициализация. Проставляются метки отрезков, определяемые формулой: \(i\cdot (m/2+1)+j\), где \(i\) - номер строки изображения, а \(j\) - порядковый номер отрезка в строке.
    \item Поиск соседних отрезков. Вносится информация о соседних отрезках, которая дальше не меняется.
    \item Сканирование. Метки отрезков заменяются на минимум от меток соседних отрезков и собственных.
    \item Анализ. Метки отрезков становятся одинаковыми в пределах каждой компоненты связности.
    \item Конечная маркировка. Происходит перенумеровка компонент, а затем внесение их в матрицу меток.
\end{enumerate}
\par Карта отрезков сделала номера отрезков зависящими не от абсолютного положения в изображении, а от относительного в строке. Поэтому стала возможным параллельная обработка изображения вообще без синхронизации, так как распараллеливать можно теперь просто по строкам. Именно это и было сделано.
\newpage
\section{Реализация паралельных алгоритмов}
\subsection{OpenMP}
\paragraph{} На 1-4 шагах алгоритма перед циклом for пишется директива \#pragma omp parallel for. На пятом шаге из-за большого количества синхронизации перенумеровка происходит последовательно, а внесение в матрицу меток - параллельно таким же образом, что и на 1-4 шагах.
\subsection{TBB}
\paragraph{} Версия TBB очень похожа на версию OpenMP, поэтому переделывать алгоритм не пришлось. Однако нужно было добавить класс-функтор - класс, основная работа которого сосредоточена в operator(). Такой класс не хранит в себе промежуточные результаты, имея среди полей только указатели на входные и выходные данные.
\par Полями функтора стали указатель на изображение и указатель на матрицу меток. А в operator() были помещены все 5 шагов алгоритма. Затем при помощи функции tbb::parallel\_for() и было проведено распараллеливание по строкам изображения.
\subsection{std::thread}
\paragraph{}  При использовании потоков C++ возникли проблемы, поэтому было решено частично заменить используемые структуры данных на более низкоуровневые. Карта отрезков, передаваемая каждому алгоритму, была заменена на массив отрезков той же длины. Изображение, представляющее собой вектор векторов, было заменено на двойной массив. Кроме того, третий этап, который представлял собой цикл for двойной вложенности внутри while, превратился просто в двойной for, а while был вынут в вызывающую функцию.
\par Для распараллеливания создаётся массив std::thread-ов, затем каждому объекту передаётся функция для параллельного выполнения через конструктор перемещения. После этого для каждого объекта выполняется метод join, чтобы дождаться выполнения всех потоков.
\newpage
\section{Результаты экспериментов}
\paragraph{} Проведено тестирование с помощью библиотеки Google Test. Они проверяли следующие ситуации:
\begin{enumerate}
    \item Пустое изображение. Всегда должна быть возвращена пустая матрица меток. В моей реализации это матрица большого размера, все элементы которой единицы.
    \item Изображение с одной компонентой, все пиксели которой не касаются края изображения. Все метки данной компоненты должны быть равны единице. Остальные - нули.
    \\\begin{center}\begin{tabular}{ |c c c c c c c| }
    \hline
     1 & 1 & 1 & 1 & 1 & 1 & 1\\
     1 & 1 & 1 & 0 & 0&1&1\\
     1 & 1 & 0 & 0 & 0&1&1\\
     1 & 0 & 0 & 0 & 0&0&1\\
     1 & 1 &0 & 0 & 0&1&1\\
     1&1&0&1&1&1&1\\
     1&1&1&1&1&1&1\\
     \hline
     \multicolumn{7}{c}{Одна компонента}
    \end{tabular}
    \end{center}
    \item Изображение с несколькими компонентами, все пиксели которых не касаются края изображения. Аналогично предыдущему пункту.
    \\\begin{center}\begin{tabular}{ |c c c c c c | }
    \hline
     1 & 1 & 1 & 1 & 1 & 1\\
     1 & 1 & 0 & 1 & 0&1\\
     1 & 0 & 0 & 1 & 0&1\\
     1 & 1 & 1 & 0 & 0&1\\
     1 & 0 &0 & 1 & 0&1\\
     1&1&1&1&1&1\\
     \hline
     \multicolumn{6}{c}{Три компоненты}
    \end{tabular}
    \end{center}
    \item Изображение с компонентами, имеющими различные форму и местоположение. Компоненты были подобраны так, чтобы учитывать множество сложных случаев параллельной маркировки.
    \\\begin{center}\begin{tabular}{ |cccccccccc | }
    \hline
     0 & 1 & 0 & 1 & 1 & 0&0&1&0&1\\
     1 & 0 & 1 & 0 & 1&0&1&1&0&0\\
     0&0&0&0&0&0&0&1&1&1\\
     0&1&0&1&0&0&0&1&1&0\\
     1&1&1&1&1&1&1&1&1&0\\
     0&0&1&0&1&0&1&0&1&0\\
     0&0&1&0&1&1&1&0&1&0\\
     1&1&1&0&0&0&0&0&1&1\\
     1&0&0&1&1&0&0&1&1&1\\
     0&0&1&1&0&0&0&1&0&1\\
     \hline
     \multicolumn{10}{c}{Различные компоненты}
    \end{tabular}
    \end{center}
    \item Изображение с компонентами в один пиксель, расположенными в шахматном порядке. Это изображение содержит максимальное число компонент - \(\Bigl \lceil \displaystyle\frac{n\cdot m}{2}\Bigr \rceil\)
    \\\begin{center}\begin{tabular}{ |cccccccc| }
    \hline
     0&1&0&1&0&1&0&1\\
     1&0&1&0&1&0&1&0\\
     0&1&0&1&0&1&0&1\\
     1&0&1&0&1&0&1&0\\
     0&1&0&1&0&1&0&1\\
     1&0&1&0&1&0&1&0\\
     0&1&0&1&0&1&0&1\\
     1&0&1&0&1&0&1&0\\
     \hline
     \multicolumn{8}{c}{Шахматный порядок}
    \end{tabular}
    \end{center}
\end{enumerate}
\par Все тесты были успешно выполнены как в последовательном, так и в параллельных случаях, что говорит о корректности реализованных алгоритмов.
\newpage
\section{Вывод}
\paragraph{} Несмотря на то, что существует большое количество алгоритмов маркировки бинарных изображений, для распараллеливания годятся не все, потому что параллельность выставляет определённые требования на алгоритмы. А те, что всё-таки могут предоставить возможность распределения работы между исполнителями (в моём случае это потоки), становятся значительно сложнее ввиду того, что они подготавливают задачу, чтобы её можно было разделять на относительно независимые блоки.
\newpage
\section{Заключение}
\paragraph{} Было проведно исследование различных известных сегодня алгоритмов, способные выполнить маркировку связанных компонент. Был разработан программный продукт, способный выполнить поставленную задачу.
\newpage
\section{Список литературы}
\begin{enumerate}
    \item Минобрнауки. Журнал Известия Юго-Западного государственного университета. Выпуск №5 (56) 2014 г. (\url{https://swsu.ru/izvestiya/journal/56_5_2014.pdf#page50})
    \item Kalentev, Oleksandr \& Rai, A. \& Kemnitz, Stefan \& Schneider, Ralf. (2011). Connected component labeling on a 2D grid using CUDA. J. Parallel Distrib. Comput.. 71. 615-620. 10.1016/j.jpdc.2010.10.012
    \item Я.М.Демяненко. Компьютерное зрение и обработка изображений. Южный федеральный университет. Институт математики, механики и компьютерных наук (\url{https://edu.mmcs.sfedu.ru/pluginfile.php/15283/mod_resource/content/10/Binary.pdf})
    \item М.Стержанов. Методики выделения связных компонент в штриховых бинарных
    изображениях. (\url{https://www.graphicon.ru/html/2010/conference/RU/Se2/12.pdf})
\end{enumerate}
\newpage
\section{Приложение}
\paragraph{} Полный исходный код приложения находится на GitHub и доступен по ссылке: \url{https://github.com/AndreyBugrov/par_pro_2023_omp_tbb_std}.
\newpage
\end{document}
